<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Live Stream</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            overflow-x: hidden;
        }

        h1 {
            margin-bottom: 1rem;
        }

        .container {
            text-align: center;
            background-color: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 400px;
            box-sizing: border-box;
        }

        #playButton {
            border: none;
            background: none;
            padding: 0;
        }

        #statusMessage {
            font-size: 18px;
            margin-top: 1rem;
            min-height: 27px;
        }

        #statusMessage.playing {
            color: green;
        }

        #statusMessage.muted {
            color: orange;
        }

        #visualizer {
            width: 100%;
            height: 100px;
            background-color: #f0f0f0;
            margin-top: 1rem;
        }

        #statistics {
            position: fixed;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #666;
            cursor: pointer;
            user-select: none;
            font-family: monospace;
        }
    </style>
</head>

<body>
    <h1>Audio Livestream</h1>
    <div class="container">
        <button id="playButton">
            <img src="play.png" alt="Play" width="64" height="64">
        </button>
        <p id="statusMessage">Connecting...</p>
    </div>
    <canvas id="visualizer"></canvas>
    <div id="statistics">Click to show statistics</div>
    <script>
        const playButton = document.getElementById('playButton');
        const statusMessage = document.getElementById('statusMessage');
        const visualizer = document.getElementById('visualizer');
        const visualizerContext = visualizer.getContext('2d');
        let audioContext;
        let webSocket;
        let micStatus = 'mic_active';
        let isPlaying = false;
        let scheduledTime = 0;
        const BUFFER_SIZE = 2048;
        let visualizerData = new Float32Array(BUFFER_SIZE);
        let sampleRate = 22000;
        let adpcmCompression = false;
        const MIN_BUFFER_DURATION = 0.1;
        const MAX_BUFFER_DURATION = 1.2;
        const CHUNK_AUDIO_DURATION = (2 * 1024) / (22000 * 2);
        const decreaseRate = Math.pow(1.5, -1 / (240 / CHUNK_AUDIO_DURATION));
        let targetBufferDuration = MIN_BUFFER_DURATION;
        let meanInterval = 0;
        let variance = 0;
        let stdDeviation = 0;
        let recommendedBuffer = 0;
        let bufferLatency = 0;

        // Variables to track packet arrival times and compute jitter
        let lastPacketArrivalTime = null;
        let packetIntervals = [];
        const JITTER_WINDOW_SIZE = 500; // Number of intervals to keep for calculations

        // Set visualizer size
        function resizeVisualizer() {
            visualizer.width = window.innerWidth;
            visualizer.height = 100;
            drawWaveform();
        }

        window.addEventListener('resize', resizeVisualizer);
        resizeVisualizer();

        // Initialize WebSocket connection immediately when page loads
        window.addEventListener('load', () => {
            webSocket = new WebSocket('ws://' + window.location.host);
            webSocket.binaryType = 'arraybuffer';

            webSocket.onopen = () => {
                console.log('WebSocket connection opened');
                statusMessage.textContent = 'Click to start audio';
                updateStatusMessage();
            };

            webSocket.onclose = () => {
                console.log('WebSocket connection closed');
                stopStream();
            };

            webSocket.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    if (event.data === 'mic_active' || event.data === 'mic_muted') {
                        micStatus = event.data;
                        updateStatusMessage();
                        if (micStatus === 'mic_muted') {
                            resetVisualizer();
                        }
                    } else if (event.data.startsWith('time:')) {
                        webSocket.send(event.data);
                    }
                } else if (event.data instanceof ArrayBuffer && isPlaying) {
                    if (micStatus === 'mic_muted') return;

                    // Measure packet arrival intervals
                    const currentTime = performance.now();

                    if (lastPacketArrivalTime !== null) {
                        const interval = currentTime - lastPacketArrivalTime;
                        packetIntervals.push(interval);

                        if (packetIntervals.length > JITTER_WINDOW_SIZE) {
                            packetIntervals.shift(); // Keep the window size fixed
                        }

                        // Calculate mean and standard deviation
                        meanInterval = packetIntervals.reduce((a, b) => a + b, 0) / packetIntervals.length;
                        variance = packetIntervals.reduce((a, b) => a + Math.pow(b - meanInterval, 2), 0) / packetIntervals.length;
                        stdDeviation = Math.sqrt(variance);

                        // Adjust targetBufferDuration to cover 99% of the delays
                        recommendedBuffer = (meanInterval + 3.5 * stdDeviation) / 1000; // Convert ms to seconds
                        targetBufferDuration = Math.min(MAX_BUFFER_DURATION, Math.max(MIN_BUFFER_DURATION, recommendedBuffer));
                    }

                    lastPacketArrivalTime = currentTime;

                    // split off first byte that encodes header information
                    const header = new Uint8Array(event.data, 0, 1)[0];
                    const body = new Uint8Array(event.data.byteLength - 1);
                    body.set(new Uint8Array(event.data, 1));
                    // first bit of header is the ADPCM flag 1 = ADPCM, 0 = PCM
                    // the rest is the sample rate in kHz
                    adpcmCompression = (header & 0b10000000) > 0;
                    sampleRate = (header & 0b01111111) * 1000;

                    let audioData;
                    if (adpcmCompression) {
                        audioData = decodeADPCM8Bit(body);
                    } else {
                        audioData = new Int16Array(body.buffer);
                    }

                    const float32Array = new Float32Array(audioData.length);
                    for (let i = 0; i < audioData.length; i++) {
                        float32Array[i] = audioData[i] / 32768;
                    }

                    updateVisualizer(float32Array);
                    processAudioData(float32Array);
                }
            };
        });

        playButton.addEventListener('click', () => {
            if (!audioContext) {
                startStream();
            } else {
                stopStream();
            }
        });

        function startStream() {
            if (!audioContext) {
                const audioContextOptions = {
                    sampleRate: 44100,
                    latencyHint: 'interactive'
                };

                audioContext = new (window.AudioContext || window.webkitAudioContext)(audioContextOptions);

                if (audioContext.state === 'suspended' && 'ontouchstart' in window) {
                    audioContext.resume();
                }

                console.log('Audio context sample rate:', audioContext.sampleRate);
                isPlaying = true;
                webSocket.send('play'); // Send play message
                playButton.innerHTML = '<img src="stop.png" alt="Stop" width="64" height="64">';
                // statusMessage.innerHTML = 'Audio playing <span style="font-size: 24px;">&#128266;</span>';
                updateStatusMessage();
            } else {
                stopStream();
            }
        }

        function stopStream() {
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            if (webSocket && webSocket.readyState === WebSocket.OPEN) {
                webSocket.send('stop'); // Send stop message
            }
            isPlaying = false;
            scheduledTime = 0;
            playButton.innerHTML = '<img src="play.png" alt="Play" width="64" height="64">';
            statusMessage.textContent = 'Click to start audio';
            statusMessage.className = '';
            updateStatusMessage();
            resetVisualizer();
        }

        function updateStatusMessage() {
            if (!audioContext) {
                statusMessage.textContent = 'Click to start audio';
                statusMessage.className = '';
            } else if (micStatus === 'mic_active') {
                statusMessage.innerHTML = 'Audio playing <span style="font-size: 24px;">&#128266;</span>';
                statusMessage.className = 'playing';
            } else {
                statusMessage.innerHTML = 'Sender is muted <span style="font-size: 24px;">&#128263;</span>';
                statusMessage.className = 'muted';
            }
        }

        let showStats = false;
        let audioGaps = [];
        let bufferTrend = 'stable';
        let lastBufferLatency = 0;
        const GAPS_WINDOW = 60000; // 1 minute in milliseconds

        function processAudioData(float32Array) {
            const currentTime = audioContext.currentTime;
            let playbackTime = Math.max(currentTime, scheduledTime);

            // Check for gaps
            if (scheduledTime > 0 && currentTime > scheduledTime + 0.01) { // Gap larger than 10ms
                audioGaps.push({
                    time: Date.now(),
                    duration: currentTime - scheduledTime
                });
            }

            // Clean up old gaps
            const now = Date.now();
            audioGaps = audioGaps.filter(gap => now - gap.time < GAPS_WINDOW);

            const resampledArray = resampleAudioData(float32Array, sampleRate, audioContext.sampleRate);
            const audioBuffer = audioContext.createBuffer(1, resampledArray.length, audioContext.sampleRate);
            audioBuffer.getChannelData(0).set(resampledArray);

            const bufferSource = audioContext.createBufferSource();
            bufferSource.buffer = audioBuffer;
            bufferSource.connect(audioContext.destination);

            // Calculate buffer latency
            bufferLatency = playbackTime - currentTime;

            // Adjust playback rate based on buffer latency
            if (bufferLatency > targetBufferDuration + 0.1) {
                // Ahead of target, speed up slightly
                bufferSource.playbackRate.value = 1.05; // 5% faster
                bufferTrend = 'decreasing';
            } else if (bufferLatency < targetBufferDuration - 0.1) {
                // Behind target, slow down slightly
                bufferSource.playbackRate.value = 0.95; // 5% slower
                bufferTrend = 'increasing';
            } else {
                // Within acceptable range
                bufferSource.playbackRate.value = 1.0;
                bufferTrend = 'stable';
            }

            bufferSource.start(playbackTime);
            scheduledTime = playbackTime + (audioBuffer.duration / bufferSource.playbackRate.value);
        }

        function updateStatistics() {
            if (!showStats) return;

            const stats = document.getElementById('statistics');

            // Use pre-calculated values from websocket onmessage
            const trendText = {
                'increasing': 'increasing',
                'decreasing': 'decreasing',
                'stable': 'stable\u00A0\u00A0\u00A0\u00A0'  // using non-breaking spaces
            }[bufferTrend];

            stats.innerHTML = `Buffer: ${Math.round(bufferLatency * 1000)}ms (${trendText}) | ` +
                `Recommended: ${Math.round(recommendedBuffer * 1000)}ms | ` +
                `Target: ${Math.round(targetBufferDuration * 1000)}ms | ` +
                `Std Dev: ${Math.round(stdDeviation)}ms | ` +  // using pre-calculated value
                `Gaps: ${audioGaps.length} in last minute | ` +
                `Click to hide statistics`;
        }

        document.getElementById('statistics').addEventListener('click', () => {
            showStats = !showStats;
            const stats = document.getElementById('statistics');
            if (!showStats) {
                stats.textContent = 'Click to show statistics';
            } else {
                updateStatistics();
            }
        });

        setInterval(updateStatistics, 500);  // Changed to 500ms

        function decodeADPCM8Bit(adpcmData) {
            // Ensure adpcmData is a Uint8Array
            if (!(adpcmData instanceof Uint8Array)) {
                adpcmData = new Uint8Array(adpcmData);
            }

            // Extract prevSample and index from the packet header
            const headerView = new DataView(adpcmData.buffer, adpcmData.byteOffset, 4);
            let prevSample = headerView.getInt16(0, true); // Little-endian
            let index = headerView.getUint8(2);
            // Skip the blank byte at headerView.getUint8(3);

            // Extract the encoded data
            const data = adpcmData.slice(4);
            const len = data.length * 2; // Each byte contains two samples
            const int16Array = new Int16Array(len);

            // Step size table (standard IMA ADPCM table with 89 entries)
            const stepSizeTable = [
                7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31,
                34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143,
                157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544,
                598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707,
                1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871,
                5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635,
                13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
            ];

            // Index table for ADPCM
            const indexTable = [-1, -1, -1, -1, 2, 4, 6, 8];

            for (let n = 0; n < data.length; n++) {
                const byte = data[n];
                // Extract two 4-bit codes
                const codeHigh = (byte >> 4) & 0x0F; // High nibble
                const codeLow = byte & 0x0F;         // Low nibble

                // Decode first sample
                let code = codeHigh;
                let step = stepSizeTable[index];
                let diffq = 0;

                let sign = code & 8;
                code = code & 7;

                if (code & 4) diffq += step;
                if (code & 2) diffq += step >> 1;
                if (code & 1) diffq += step >> 2;
                diffq += step >> 3;

                if (sign)
                    prevSample -= diffq;
                else
                    prevSample += diffq;

                // Clamp prevSample
                if (prevSample > 32767)
                    prevSample = 32767;
                else if (prevSample < -32768)
                    prevSample = -32768;

                int16Array[n * 2] = prevSample;

                // Update index
                index += indexTable[code];
                if (index < 0)
                    index = 0;
                else if (index > 88)
                    index = 88;

                // Decode second sample
                code = codeLow;
                step = stepSizeTable[index];
                diffq = 0;

                sign = code & 8;
                code = code & 7;

                if (code & 4) diffq += step;
                if (code & 2) diffq += step >> 1;
                if (code & 1) diffq += step >> 2;
                diffq += step >> 3;

                if (sign)
                    prevSample -= diffq;
                else
                    prevSample += diffq;

                // Clamp prevSample
                if (prevSample > 32767)
                    prevSample = 32767;
                else if (prevSample < -32768)
                    prevSample = -32768;

                int16Array[n * 2 + 1] = prevSample;

                // Update index
                index += indexTable[code];
                if (index < 0)
                    index = 0;
                else if (index > 88)
                    index = 88;
            }

            return int16Array;
        }



        function resampleAudioData(inputArray, inputSampleRate, outputSampleRate) {
            if (inputSampleRate === outputSampleRate) {
                return inputArray;
            }

            const sampleRateRatio = outputSampleRate / inputSampleRate;
            const newLength = Math.round(inputArray.length * sampleRateRatio);
            const outputArray = new Float32Array(newLength);

            for (let i = 0; i < newLength; i++) {
                const idx = i / sampleRateRatio;
                const idx_low = Math.floor(idx);
                const idx_high = Math.min(idx_low + 1, inputArray.length - 1);
                const weight = idx - idx_low;
                outputArray[i] = (1 - weight) * inputArray[idx_low] + weight * inputArray[idx_high];
            }
            return outputArray;
        }

        function updateVisualizer(newData) {
            visualizerData = new Float32Array([...visualizerData.slice(newData.length), ...newData]);
            drawWaveform();
        }

        function resetVisualizer() {
            visualizerData.fill(0);
            drawWaveform();
        }

        function drawWaveform() {
            visualizerContext.clearRect(0, 0, visualizer.width, visualizer.height);
            visualizerContext.beginPath();
            visualizerContext.strokeStyle = '#3498db';
            visualizerContext.lineWidth = 2;

            const sliceWidth = visualizer.width / visualizerData.length;
            for (let i = 0; i < visualizerData.length; i++) {
                const x = i * sliceWidth;
                const y = (visualizerData[i] + 1) * visualizer.height / 2;

                if (i === 0) {
                    visualizerContext.moveTo(x, y);
                } else {
                    visualizerContext.lineTo(x, y);
                }
            }

            visualizerContext.stroke();
        }

        // Initial draw of the waveform
        drawWaveform();

        // Check for Safari browser and show dialog
        // if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        //     alert("In case you're not using headphones, make sure that your device is not set to silent mode.");
        // }
    </script>
</body>

</html>